---
title: "Tutorial de R"
output: html_notebook
---

# 0. Conceptos básicos

Antes de comenzar el tutorial, debemos recordar como se declaran e inicializan las variables en el lenguaje de programación R.
```{r}
#Las variables se pueden declarar e inicializar de dos maneras:

version1 <- "Primera versión"; #Flecha
version2 = "Segunda versión"; #Igual

#Las variables pueden tener los siguientes tipos de datos:

numero <- 69;
texto = "Texto";
booleano <- TRUE;
```


# 1. Estructuras de control en R

Como su nombre lo indica, las estructuras de control nos permiten controlar la manera en que se ejecuta nuestro código.

Las estructuras de control establecen condicionales en nuestros código. Por ejemplo, qué condiciones deben cumplirse para realizar una operación o qué debe ocurrir para ejecutar una función.

Esto es de gran utilidad para determinar la lógica y el orden en que ocurren las operaciones, en especial al definir funciones.
```{r}
#Las estructuras de control más usadas en R son las siguientes.

#IF / ELSE - Es utilizado cuando queremos que una función se ejecute cuando se cumpla o no una condición.

edad = 20;

if( edad >= 18) { #CONDICION: Si la edad es mayor o igual a 18...
  print('Eres mayor de edad'); #Imprimir Eres mayor de edad
} else { #Si no es mayor o igual a 18
  print('No eres mayor de edad'); #Imprimir Eres menor de edad
}

#FOR - Nos permite ejecutar un bucle, realizando una operación para cada elemento de un conjunto de datos.

for(multiplo in 1:10) { #Se van a imprimir los primeros 10 múltiplos de 5 
  print(5 * multiplo);
}

#WHILE - Este es un tipo de bucle que ocurre mientras una condición es verdadera (TRUE). La operación se realiza hasta que se se llega a cumplir un criterio previamente establecido.

limite <- 5
valor <- 0

while(valor < limite) { #Mientras valor sea menor a limite, imprime Todavia no y aumentale 1 a valor
  print("Todavía no.")
  valor <- valor + 1
}

#BREAK Y NEXT - son palabras reservadas en R, no podemos asignarles nuevos valores y realizan una operación específica cuando aparecen en nuestro código. break nos permite interrumpir un bucle, mientras que next nos deja avanzar a la siguiente iteración del bucle, “saltándose” la actual. Ambas funcionan para for y while.

for(i in 1:10) { #Imprime números del 1 al 10, pero si i vale 5, interrumpe el proceso.
  if(i == 5) {
    break
  }
  print(i)
}

for(i in 1:10) { #Imprime números del 1 al 10, pero si i vale 5, se omite.
  if(i == 5) {
    next
  }
  print(i)
}
```


# 2. Vectores en R. Creación, indexación, edición.

Un vector es la estructura de datos más sencilla en R. Un vector es una colección de uno o más datos del mismo tipo. Estos vectores tienen un tipo, largo y atributos.
```{r}
#CREACION DE VECTORES
#Para crear un vector debemos utilizar la funcion c()

c(1,2,3,4); #Vector de numeros
c('Hola', 'como', 'estas?'); #Vector de texto
c(FALSE, TRUE, FALSE) #Vector booleano

#También podemos generar vectores con :
1:10
-10:-1

#Podemos añadir valores nuevos a los vectores:
miVector = c(1,2,3,4);
c(miVector, 5);

#Podemos realizar operaciones generales:
miVector + 2
miVector * 2
miVector / 2
miVector < 2

#INDEXACION
#Podemos acceder a las posiciones de los vectores mediante []:
miVector[1]; #Primer valor
miVector[-1]; #Todos excepto el primer valor
miVector[miVector<2] #Los valores menores a 2
miVector[1:3] #Posicion 1 a 3
miVector[-1:-3] #Todos excepto los de posición 1 a 3

#EDICION
#Podemos cambiar los valores del vector en cualquier momento
miVector[1:4] = 5;
miVector
```

# 3. Listas y matrices en R

Las matrices pueden ser descritas como vectores multidimensionales. Al igual que un vector, únicamente pueden contener datos de un sólo tipo, pero además de largo, tienen más dimensiones.
```{r}
#Para crear una matriz debemos usar la función matrix():
matrix(1:12)

#Se pueden especificar el número de filas y columnas
matrix(1:12, nrow = 3, ncol = 4)

#Podemos unir vectores para hacer una matriz usando rbind:
vector_1 <- 1:4
vector_2 <- 5:8
vector_3 <- 9:12
vector_4 <- 13:16

matriz <- rbind(vector_1, vector_2, vector_3, vector_4)
matriz

#Podemos acceder a los valores de la matriz:

P <- matrix(c(3:14), nrow = 4, byrow = TRUE)
P
print(P[1,3])
print(P[4,2])

#Las matrices se pueden operar entre sí si cumplen las condiciones:

matrix1 <- matrix(c(3, 9, -1, 4, 2, 6), nrow = 2)
matrix2 <- matrix(c(5, 2, 0, 9, 3, 4), nrow = 2)
matrix1 + matrix2
matrix1 - matrix2
matrix1 * matrix2
matrix1 / matrix2

#Se pueden hacer diferentes operaciones con las matrices, por ejemplo, hacer la transpuesta:
matriz <- matrix(1:6, nrow = 3)
matriz
matriz_t <- t(matriz)
matriz_t
```
Las listas, al igual que los vectores, son estructuras de datos unidimensionales, sólo tienen largo, pero a diferencia de los vectores cada uno de sus elementos puede ser de diferente tipo o incluso de diferente clase, por lo que son estructuras heterogéneas.

```{r}
#Podemos crear una lista con list():
mi_vector <- 1:10
mi_matriz <- matrix(1:4, nrow = 2)
mi_lista <- list("un_vector" = mi_vector, "una_matriz" = mi_matriz)
mi_lista

#Llamar elementos de una lista
mi_lista[1]
mi_lista$una_matriz

#Añadir nuevos elementos a una lista
mi_lista[[3]] <- data.frame(X = c(8, 5, 3), Y = c(7, 9, 1))
mi_lista

#Concatenar listas
mi_lista2 <- list("Vector" = 1:20);
append(mi_lista, mi_lista2)

# Devuelve los elementos comunes
intersect(mi_lista, mi_lista2)

#Diferencia entre listas
setdiff(mi_lista, mi_lista2)
```

4-      Dataframes. Visualización y manipulación. Ejemplo utilización dataframe. Encuentro un dataset en internet o que se encuentre disponible en alguna librería en R y utilice la funcionalidad del dataframe para extraer información del dataset. Utilice las funciones promedio, desviación estándar, varianza para resumir la información en el dataframe.
```{r}

```

5-      Funciones en R. Ejemplos de utilización. Implemente una función en R de su elección. Explique paso a paso la función y la manera en que retorna los valores finales. Explique también como invocar la función
```{r}

```

6-      Manejo de archivos con R
```{r}

```

7-      Ejemplos de visualización de datos: Gráficas diversas incluyendo dispersión de puntos, histogramas, diagrama de cajas (bloxpots), violinplots, etc.

LOs gráficos en R se pueden realizar de forma básica usando las funciones integradas en el lenguaje o avanzada con el paquete ggplot2.

```{r}
if(!require("AER")) {install.packages("AER")}
#data(package="AER")
#library(AER)
data("CPS1985")
```
Histograma
```{r}
attach(CPS1985)   # acceder directamente a las variables (columnas)
hist(wage,
     breaks = 20,   # número de intervalos
     main = "Distribución del Salario (dólares por hora)",    # título del gráfico
     xlab = "Salario",                                        # título del eje x
     ylab = "Número de personas",                              # título del eje y
     xlim = c(0,50),                      # rango de valores del eje x
     col = "blue",                        # color de relleno
     border = "white"                     # color del borde del rectángulo
     )
```
```{r}
hist(wage,
     breaks = 20,   
     main = "Distribución del Salario (dólares por hora)", 
     freq = FALSE,
     xlab = "Salario",                                          
     ylab = "Frecuencia relativa (en tanto por uno)", 
     xlim = c(0,50),
     ylim = c(0,0.15),
     col = "blue",
     border = "white"
     )

lines(density(wage), col="yellow", lwd=3)  # dibujamos la distribución normal empírica con los  datos que tenemos

lines(density(wage, adjust=2), col="red", lwd=3, lty=2) # adjust=2 lo que hace es suavizar un poco la curva (probad con adjust=1 y adjust=5 para ver las diferencias).
curve(dnorm(x, mean=mean(wage), sd=sd(wage)), add=TRUE, col="orange", lwd=3)  # aquí simulamos valores de una normal con la misma media y deviación típica que wage y la representamos.
abline(v=mean(wage), lwd=2, lty=3, col="darkblue")    # añadimos posición de la media. Recordemos que e argumento "lwd"" hace referencia al grosor de la línea y "lty"" al tipo de línea.
```
Boxplot
```{r}
boxplot(wage ~ gender,
        main = "Salario (dólares hora) según género",
        ylab = "Salario",
        names = c("Hombres","Mujeres")   # cambiamos la etiqueta de la variable cualitativa
        )
```
```{r}
a <- rainbow(6)
b <- rainbow(6, alpha=0.2)
c <- rainbow(6, v=0.5)


boxplot(wage ~ occupation,
        col = b,       
        boxcol = c,     
        medcol = c,   
        whiskcol = a,  
        staplecol = c,   
        outcol = c,    
        outbg = c,     
        pch = 20,        
        cex = 1,         
        horizontal = T,  
        main = "Salario (dólares hora) según ocupación",
        xlab = "Salario",
        yaxt = "n"              # elminamos el eje y
        )

legend("bottomright", title="Salario (dólares hora)", levels(occupation), fill=b)
```
Diagrama de dispersiòn
```{r}
sexo <- as.numeric(gender)

plot (log(wage) ~ experience,
      pch = sexo,
      col = sexo,
      main = "Salario (en logaritmos) en función de la experiencia",
      xlab = "Experiencia (en años)",
      ylab = "Salario (en logaritmos)"
      )

with(CPS1985[gender=="male",], abline(lm(log(wage)~experience), col="red"))
with(CPS1985[gender=="female",], abline(lm(log(wage)~experience), col="black"))

legend("topright", legend=c("Hombres","Mujeres"), pch=1:2, col=1:2, bty="y")
```

Diagrama de barras
```{r}
educacion <- table(education)
p <- barplot(educacion,
        col = 1:dim(educacion),       # para establecer el número de diferentes colores                                       (=diferentes valores)
        space = 0,                    # no espacio entre las barras
        horiz = F,                    # orientación de las barras
        density = 50 ,                # trama de las barras (se puede modificar el ángulo con                                     el argumento angle)
        ylim = c(0,250)
        )

title("Distribución de la edad", xlab= "Edad (en años)")
text(p[,1],educacion,labels=educacion, pos=3,cex=0.75)
```
```{r}
p <- table(ethnicity, gender) 
barplot(p,
        beside=T,  # si es FALSE apila
        col=rainbow(3),
        legend=levels(ethnicity),
        names.arg= levels(gender),
        ylim=c(0,250)
        
)
```
Grafico de sectores
```{r}
datos <- table(ethnicity)
pie(datos, 
    labels=c("Caucásicos", "Hispanos", "Otros"), 
    col=heat.colors(3),
    main= "Gráfico de sectores")
```
Gráfico de mosaico

```{r}
install.packages("vcd")
library(vcd)
datos <- ftable(occupation, ethnicity, gender)
mosaic(~ occupation + ethnicity + gender , dat=datos, las=1)
```
Violinplot

```{r}
install.packages("vioplot")
library(vioplot)
x <- c(6, 9, 0, 19, -1, 8, 12, 5, 3, 7,
       2, 4, 3, -8, -9, 8, 4, 12, 5, 14)
vioplot(x,
        col = 2,               # Color del área
        rectCol = "red",       # Color del rectángulo
        lineCol = "white",     # Color de la línea
        colMed = "green",      # Color del símbolo pch
        border = "black",      # Color del borde del violín
        pchMed = 16,           # Símbolo pch para la mediana
        plotCentre = "points", # Si "line", dibuja una línea en la mediana
        horizontal = TRUE)
```


```{r}
data <- chickwts

stripchart(data$weight ~ data$feed, vertical = TRUE, method = "jitter",
           pch = 19, add = TRUE, col = 3:8)
```


Ahora, veremos los gràficos con ggplot2:

```{r}
install.packages("ggplot2")
library(ggplot2)
```


```{r}
ggplot(CPS1985, aes(x=wage)) + 
  geom_histogram(bins=20, color="white", fill="blue") +
  facet_grid(gender~.)
```
```{r}
ggplot(CPS1985, aes(x=wage)) + 
  geom_histogram(aes(y=..density..), bins=20, color="white", fill="grey") + 
  stat_function(fun = dnorm, colour = "red",
                args = list(mean = mean(wage, na.rm = TRUE),
                                 sd = sd(wage, na.rm = TRUE))) +
  geom_line(stat="density", color="blue") +
  expand_limits(y=0)
```


